<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Entity Component System: ecs::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Entity Component System
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Entity Component System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecs.html">ecs</a></li><li class="navelem"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classecs_1_1_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecs::ThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class representing dynamic pool of computing threads.  
 <a href="classecs_1_1_thread_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf5764f5de45e1ca425118d1a1b95657"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#acf5764f5de45e1ca425118d1a1b95657">ThreadPool</a> (const unsigned thread_count=2u)</td></tr>
<tr class="memdesc:acf5764f5de45e1ca425118d1a1b95657"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor of the <a class="el" href="classecs_1_1_thread_pool.html" title="The class representing dynamic pool of computing threads.">ThreadPool</a> class.  <a href="classecs_1_1_thread_pool.html#acf5764f5de45e1ca425118d1a1b95657">More...</a><br /></td></tr>
<tr class="separator:acf5764f5de45e1ca425118d1a1b95657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9a7e95e3ebc8b77a8506e6ef7dfa10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aea9a7e95e3ebc8b77a8506e6ef7dfa10">ThreadPool</a> (const <a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="separator:aea9a7e95e3ebc8b77a8506e6ef7dfa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83ca9d98458376b78fb4c7108583dd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ad83ca9d98458376b78fb4c7108583dd0">ThreadPool</a> (<a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad83ca9d98458376b78fb4c7108583dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd68ebf11e8d9214153e44eb34ceeae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a1cd68ebf11e8d9214153e44eb34ceeae">operator=</a> (const <a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="separator:a1cd68ebf11e8d9214153e44eb34ceeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb84aa429291bd997bb7aab0c824f758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#abb84aa429291bd997bb7aab0c824f758">operator=</a> (<a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:abb84aa429291bd997bb7aab0c824f758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87879b5716e50d21872baa52a55b96c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ad87879b5716e50d21872baa52a55b96c">~ThreadPool</a> ()</td></tr>
<tr class="separator:ad87879b5716e50d21872baa52a55b96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb38043cd68a08f182039fb6d193a961"><td class="memItemLeft" align="right" valign="top">std::thread &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#adb38043cd68a08f182039fb6d193a961">getThread</a> (const unsigned id)</td></tr>
<tr class="memdesc:adb38043cd68a08f182039fb6d193a961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread instance from the pool.  <a href="classecs_1_1_thread_pool.html#adb38043cd68a08f182039fb6d193a961">More...</a><br /></td></tr>
<tr class="separator:adb38043cd68a08f182039fb6d193a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ecc48197127c0c4ef0a6235760597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a0a4ecc48197127c0c4ef0a6235760597">totalThreadCount</a> () const</td></tr>
<tr class="memdesc:a0a4ecc48197127c0c4ef0a6235760597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of threads in the pool.  <a href="classecs_1_1_thread_pool.html#a0a4ecc48197127c0c4ef0a6235760597">More...</a><br /></td></tr>
<tr class="separator:a0a4ecc48197127c0c4ef0a6235760597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a54ec2564e97518c1ac812cd92049dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a2a54ec2564e97518c1ac812cd92049dd">idleThreadCount</a> () const</td></tr>
<tr class="memdesc:a2a54ec2564e97518c1ac812cd92049dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of idle threads in the pool.  <a href="classecs_1_1_thread_pool.html#a2a54ec2564e97518c1ac812cd92049dd">More...</a><br /></td></tr>
<tr class="separator:a2a54ec2564e97518c1ac812cd92049dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae884b4c11e1067fc7b2adbf737dd3819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ae884b4c11e1067fc7b2adbf737dd3819">pendingTasksCount</a> () const</td></tr>
<tr class="memdesc:ae884b4c11e1067fc7b2adbf737dd3819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pending tasks in the queue.  <a href="classecs_1_1_thread_pool.html#ae884b4c11e1067fc7b2adbf737dd3819">More...</a><br /></td></tr>
<tr class="separator:ae884b4c11e1067fc7b2adbf737dd3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe165e19b30390f76a9ef9326a230de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#abe165e19b30390f76a9ef9326a230de4">resize</a> (const unsigned thread_count)</td></tr>
<tr class="memdesc:abe165e19b30390f76a9ef9326a230de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the thread pool (changes the number of working threads).  <a href="classecs_1_1_thread_pool.html#abe165e19b30390f76a9ef9326a230de4">More...</a><br /></td></tr>
<tr class="separator:abe165e19b30390f76a9ef9326a230de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208e35ab2af5bd86553f617ea41b8ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3">halt</a> (const bool finish_tasks=false)</td></tr>
<tr class="memdesc:a208e35ab2af5bd86553f617ea41b8ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all threads.  <a href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3">More...</a><br /></td></tr>
<tr class="separator:a208e35ab2af5bd86553f617ea41b8ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ec690f14c0cc15d06b8a9bbb59d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50">haltInfinite</a> ()</td></tr>
<tr class="memdesc:acd9ec690f14c0cc15d06b8a9bbb59d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all threads with infinite tasks.  <a href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50">More...</a><br /></td></tr>
<tr class="separator:acd9ec690f14c0cc15d06b8a9bbb59d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1283598be193563a0f7485871bf4357c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a1283598be193563a0f7485871bf4357c">restart</a> ()</td></tr>
<tr class="memdesc:a1283598be193563a0f7485871bf4357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts the thread pool.  <a href="classecs_1_1_thread_pool.html#a1283598be193563a0f7485871bf4357c">More...</a><br /></td></tr>
<tr class="separator:a1283598be193563a0f7485871bf4357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328a842f3862c0a27db52c4dcc10747"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ab328a842f3862c0a27db52c4dcc10747"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747">addTask</a> (Functor &amp;&amp;func) -&gt; std::future&lt; decltype(func(0))&gt;</td></tr>
<tr class="memdesc:ab328a842f3862c0a27db52c4dcc10747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new task to the queue.  <a href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747">More...</a><br /></td></tr>
<tr class="separator:ab328a842f3862c0a27db52c4dcc10747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa190f4592f202e9a0e7b08efff45f56a"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:aa190f4592f202e9a0e7b08efff45f56a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aa190f4592f202e9a0e7b08efff45f56a">addTask</a> (Functor &amp;&amp;func) -&gt; std::future&lt; decltype(func())&gt;</td></tr>
<tr class="memdesc:aa190f4592f202e9a0e7b08efff45f56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new task to the queue.  <a href="classecs_1_1_thread_pool.html#aa190f4592f202e9a0e7b08efff45f56a">More...</a><br /></td></tr>
<tr class="separator:aa190f4592f202e9a0e7b08efff45f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6719fa01f4d2ba112360083f8037e2e"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:aa6719fa01f4d2ba112360083f8037e2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aa6719fa01f4d2ba112360083f8037e2e">addTask</a> (Functor &amp;&amp;func, Args &amp;&amp;...arguments) -&gt; std::future&lt; decltype(func(0, arguments...))&gt;</td></tr>
<tr class="memdesc:aa6719fa01f4d2ba112360083f8037e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new task to the queue.  <a href="classecs_1_1_thread_pool.html#aa6719fa01f4d2ba112360083f8037e2e">More...</a><br /></td></tr>
<tr class="separator:aa6719fa01f4d2ba112360083f8037e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58e31026627818ba5695b979c9340aa"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:aa58e31026627818ba5695b979c9340aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aa58e31026627818ba5695b979c9340aa">addTask</a> (Functor &amp;&amp;func, Args &amp;&amp;...arguments) -&gt; std::future&lt; decltype(func(arguments...))&gt;</td></tr>
<tr class="memdesc:aa58e31026627818ba5695b979c9340aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new task to the queue.  <a href="classecs_1_1_thread_pool.html#aa58e31026627818ba5695b979c9340aa">More...</a><br /></td></tr>
<tr class="separator:aa58e31026627818ba5695b979c9340aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f4d1827bc69c1b8c22f64da160c85"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:aa06f4d1827bc69c1b8c22f64da160c85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85">addInfiniteTask</a> (Functor &amp;&amp;func) -&gt; std::future&lt; decltype(func(0))&gt;</td></tr>
<tr class="memdesc:aa06f4d1827bc69c1b8c22f64da160c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new infinite task to the queue.  <a href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85">More...</a><br /></td></tr>
<tr class="separator:aa06f4d1827bc69c1b8c22f64da160c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a3d6c7b7e5cca8df0636daa9d54d7e"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a41a3d6c7b7e5cca8df0636daa9d54d7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a41a3d6c7b7e5cca8df0636daa9d54d7e">addInfiniteTask</a> (Functor &amp;&amp;func) -&gt; std::future&lt; decltype(func())&gt;</td></tr>
<tr class="memdesc:a41a3d6c7b7e5cca8df0636daa9d54d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new infinite task to the queue.  <a href="classecs_1_1_thread_pool.html#a41a3d6c7b7e5cca8df0636daa9d54d7e">More...</a><br /></td></tr>
<tr class="separator:a41a3d6c7b7e5cca8df0636daa9d54d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8324166be60e316791d6a6dea185e788"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a8324166be60e316791d6a6dea185e788"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a8324166be60e316791d6a6dea185e788">addInfiniteTask</a> (Functor &amp;&amp;func, Args &amp;&amp;...arguments) -&gt; std::future&lt; decltype(func(0, arguments...))&gt;</td></tr>
<tr class="memdesc:a8324166be60e316791d6a6dea185e788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new infinite task to the queue.  <a href="classecs_1_1_thread_pool.html#a8324166be60e316791d6a6dea185e788">More...</a><br /></td></tr>
<tr class="separator:a8324166be60e316791d6a6dea185e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23831ba1a9c74399806c9869bed59720"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a23831ba1a9c74399806c9869bed59720"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a23831ba1a9c74399806c9869bed59720">addInfiniteTask</a> (Functor &amp;&amp;func, Args &amp;&amp;...arguments) -&gt; std::future&lt; decltype(func(arguments...))&gt;</td></tr>
<tr class="memdesc:a23831ba1a9c74399806c9869bed59720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new infinite task to the queue.  <a href="classecs_1_1_thread_pool.html#a23831ba1a9c74399806c9869bed59720">More...</a><br /></td></tr>
<tr class="separator:a23831ba1a9c74399806c9869bed59720"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa2f782b1361dddb46f53c61c39b377fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aa2f782b1361dddb46f53c61c39b377fc">setupThread</a> (const int index)</td></tr>
<tr class="memdesc:aa2f782b1361dddb46f53c61c39b377fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a thread for computing.  <a href="classecs_1_1_thread_pool.html#aa2f782b1361dddb46f53c61c39b377fc">More...</a><br /></td></tr>
<tr class="separator:aa2f782b1361dddb46f53c61c39b377fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e476ddc2bd3dd92b4ff1c065fd63065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a2e476ddc2bd3dd92b4ff1c065fd63065">clearQueue</a> ()</td></tr>
<tr class="memdesc:a2e476ddc2bd3dd92b4ff1c065fd63065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue of tasks.  <a href="classecs_1_1_thread_pool.html#a2e476ddc2bd3dd92b4ff1c065fd63065">More...</a><br /></td></tr>
<tr class="separator:a2e476ddc2bd3dd92b4ff1c065fd63065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac735d2da7345482bc841608c0b06a6fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; std::thread &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ac735d2da7345482bc841608c0b06a6fe">m_threads</a></td></tr>
<tr class="separator:ac735d2da7345482bc841608c0b06a6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e568cb7d681a0ce9c60ed754e67b273"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; std::atomic&lt; bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a4e568cb7d681a0ce9c60ed754e67b273">m_abortFlags</a></td></tr>
<tr class="separator:a4e568cb7d681a0ce9c60ed754e67b273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0472a17346187879cf61165de548f4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classecs_1_1impl_1_1_safe_queue.html">impl::SafeQueue</a>&lt; std::function&lt; void(const int)&gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a0472a17346187879cf61165de548f4b1">m_queue</a></td></tr>
<tr class="separator:a0472a17346187879cf61165de548f4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5be0fb027093062de23e0b006de4bc"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#aad5be0fb027093062de23e0b006de4bc">m_finishedFlag</a></td></tr>
<tr class="separator:aad5be0fb027093062de23e0b006de4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c071ae20800eeeeab50feac14ffc33"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#ad3c071ae20800eeeeab50feac14ffc33">m_haltFlag</a></td></tr>
<tr class="separator:ad3c071ae20800eeeeab50feac14ffc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f45a02bde7e9978f078bf6c7d53a1"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a218f45a02bde7e9978f078bf6c7d53a1">m_infHaltFlag</a></td></tr>
<tr class="separator:a218f45a02bde7e9978f078bf6c7d53a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c683b6f2a282ac8caa8fc524a04f30c"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a5c683b6f2a282ac8caa8fc524a04f30c">m_waitingThreadsCount</a></td></tr>
<tr class="separator:a5c683b6f2a282ac8caa8fc524a04f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e624de9d93cd6182f5a8b6bd7eeffdb"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a9e624de9d93cd6182f5a8b6bd7eeffdb">m_pendingTasksCount</a></td></tr>
<tr class="separator:a9e624de9d93cd6182f5a8b6bd7eeffdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ac8412f189847a24b3df04efac75fc"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a37ac8412f189847a24b3df04efac75fc">m_mutex</a></td></tr>
<tr class="separator:a37ac8412f189847a24b3df04efac75fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb8a7cc00049e7999b5e2bcaad2da21"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_thread_pool.html#a3eb8a7cc00049e7999b5e2bcaad2da21">m_cond</a></td></tr>
<tr class="separator:a3eb8a7cc00049e7999b5e2bcaad2da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class representing dynamic pool of computing threads. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf5764f5de45e1ca425118d1a1b95657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5764f5de45e1ca425118d1a1b95657">&#9670;&nbsp;</a></span>ThreadPool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecs::ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>2u</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor of the <a class="el" href="classecs_1_1_thread_pool.html" title="The class representing dynamic pool of computing threads.">ThreadPool</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>The number of created threads.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, thread count is set to minimal logical value, which is 2. To unleash full power of multithreading, check your hardware capabilities and pass the maximal value. </p><div class="fragment"><div class="line">std::size_t thcount = std::thread::hardware_concurrency</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aea9a7e95e3ebc8b77a8506e6ef7dfa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9a7e95e3ebc8b77a8506e6ef7dfa10">&#9670;&nbsp;</a></span>ThreadPool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ecs::ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted copy constructor. </p>

</div>
</div>
<a id="ad83ca9d98458376b78fb4c7108583dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83ca9d98458376b78fb4c7108583dd0">&#9670;&nbsp;</a></span>ThreadPool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ecs::ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted move constructor. </p>

</div>
</div>
<a id="ad87879b5716e50d21872baa52a55b96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87879b5716e50d21872baa52a55b96c">&#9670;&nbsp;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ecs::ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The virtual destructor, which calls halt(true) and <a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50" title="Stops all threads with infinite tasks.">haltInfinite()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41a3d6c7b7e5cca8df0636daa9d54d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a3d6c7b7e5cca8df0636daa9d54d7e">&#9670;&nbsp;</a></span>addInfiniteTask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addInfiniteTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt;  std::future&lt; decltype(func())&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new infinite task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which will hold the returned result (if any) of the last execution.</dd></dl>
<p>This method is and overload of the previous <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> and it does not require to add a const int argument to the function parameters.</p>
<p>The difference between <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> is that in the latter the function's body is nested inside a while(true) loop. This means that the function will be constantly executed until <a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3" title="Stops all threads.">halt()</a> or <a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50" title="Stops all threads with infinite tasks.">haltInfinite()</a> is called.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task() { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello darkness my old friend...&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addInfiniteTask(task);</div>
<div class="line">    TP.halt(<span class="keyword">false</span>);  <span class="comment">// this line is important, because it stops the infinite task</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output:</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa06f4d1827bc69c1b8c22f64da160c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f4d1827bc69c1b8c22f64da160c85">&#9670;&nbsp;</a></span>addInfiniteTask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addInfiniteTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt;  std::future&lt; decltype(func(0))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new infinite task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which will hold the returned result (if any) of the last execution.</dd></dl>
<p>Functions require the first argument to have a const int, because <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> passes a thread id to it for the use by the function.</p>
<p>The difference between <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> is that in the latter the function's body is nested inside a while(true) loop. This means that the function will be constantly executed until <a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3" title="Stops all threads.">halt()</a> or <a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50" title="Stops all threads with infinite tasks.">haltInfinite()</a> is called.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(<span class="keyword">const</span> <span class="keywordtype">int</span> thread_id) { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello from thread &quot;</span> &lt;&lt; thread_id &lt;&lt; std::endl; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addInfiniteTask(task);</div>
<div class="line">    TP.halt(<span class="keyword">false</span>);  <span class="comment">// this line is important, because it stops the infinite task</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// A is an index of the thread in &lt;0-3&gt; domain.</span></div>
<div class="line"><span class="comment">// Output:</span></div>
<div class="line"><span class="comment">// Hello from thread A</span></div>
<div class="line"><span class="comment">// Hello from thread A</span></div>
<div class="line"><span class="comment">// Hello from thread A</span></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8324166be60e316791d6a6dea185e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8324166be60e316791d6a6dea185e788">&#9670;&nbsp;</a></span>addInfiniteTask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addInfiniteTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::future&lt; decltype(func(0, arguments...))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new infinite task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
    <tr><td class="paramname">arguments</td><td>The extra arguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the extra erguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which will hold the returned result (if any) of the last execution.</dd></dl>
<p>Functions require the first argument to have a const int, because <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> passes a thread id to it for the use by the function.</p>
<p>The difference between <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> is that in the latter the function's body is nested inside a while(true) loop. This means that the function will be constantly executed until <a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3" title="Stops all threads.">halt()</a> or <a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50" title="Stops all threads with infinite tasks.">haltInfinite()</a> is called.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(<span class="keyword">const</span> <span class="keywordtype">int</span> thread_id, <span class="keyword">const</span> std::string &amp;additional_parameter) { std::cout &lt;&lt; additional_parameter &lt;&lt; <span class="stringliteral">&quot; from thread &quot;</span> &lt;&lt; thread_id &lt;&lt; std::endl; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addInfiniteTask(task, <span class="stringliteral">&quot;Hello there&quot;</span>);</div>
<div class="line">    TP.halt(<span class="keyword">false</span>);  <span class="comment">// this line is important, because it stops the infinite task</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// A is an index of the thread in &lt;0-3&gt; domain.</span></div>
<div class="line"><span class="comment">// Output:</span></div>
<div class="line"><span class="comment">// Hello there from thread A</span></div>
<div class="line"><span class="comment">// Hello there from thread A</span></div>
<div class="line"><span class="comment">// Hello there from thread A</span></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23831ba1a9c74399806c9869bed59720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23831ba1a9c74399806c9869bed59720">&#9670;&nbsp;</a></span>addInfiniteTask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addInfiniteTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::future&lt; decltype(func(arguments...))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new infinite task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
    <tr><td class="paramname">arguments</td><td>The extra arguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the extra erguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which will hold the returned result (if any) of the last execution.</dd></dl>
<p>This method is and overload of the previous <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> and it does not require to add a const int argument to the function parameters.</p>
<p>The difference between <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and <a class="el" href="classecs_1_1_thread_pool.html#aa06f4d1827bc69c1b8c22f64da160c85" title="Adds a new infinite task to the queue.">addInfiniteTask()</a> is that in the latter the function's body is nested inside a while(true) loop. This means that the function will be constantly executed until <a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3" title="Stops all threads.">halt()</a> or <a class="el" href="classecs_1_1_thread_pool.html#acd9ec690f14c0cc15d06b8a9bbb59d50" title="Stops all threads with infinite tasks.">haltInfinite()</a> is called.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(<span class="keyword">const</span> std::string &amp;additional_parameter) { std::cout &lt;&lt; additional_parameter &lt;&lt; std::endl; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addInfiniteTask(task, <span class="stringliteral">&quot;Hello darkness my old friend...&quot;</span>);</div>
<div class="line">    TP.halt(<span class="keyword">false</span>);  <span class="comment">// this line is important, because it stops the infinite task</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output:</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// Hello darkness my old friend...</span></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa190f4592f202e9a0e7b08efff45f56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa190f4592f202e9a0e7b08efff45f56a">&#9670;&nbsp;</a></span>addTask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt;  std::future&lt; decltype(func())&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which after execution will hold the returned result (if any).</dd></dl>
<p>This method is and overload of the previous <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and it does not require to add a const int argument to the function parameters.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task() { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world!&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addTask(task);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output: Hello world!</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab328a842f3862c0a27db52c4dcc10747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328a842f3862c0a27db52c4dcc10747">&#9670;&nbsp;</a></span>addTask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt;  std::future&lt; decltype(func(0))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which after execution will hold the returned result (if any).</dd></dl>
<p>Functions require the first argument to have a const int, because <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> passes a thread id to it for the use by the function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(<span class="keyword">const</span> <span class="keywordtype">int</span> thread_id) { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello from thread &quot;</span> &lt;&lt; thread_id; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addTask(task);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output: Hello from thread &lt;0-3&gt;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6719fa01f4d2ba112360083f8037e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6719fa01f4d2ba112360083f8037e2e">&#9670;&nbsp;</a></span>addTask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::future&lt; decltype(func(0, arguments...))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
    <tr><td class="paramname">arguments</td><td>The extra arguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the extra erguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which after execution will hold the returned result (if any).</dd></dl>
<p>Functions require the first argument to have a const int, because <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> passes a thread id to it for the use by the function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(<span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::string additional_parameter) { std::cout &lt;&lt; additional_parameter &lt;&lt; <span class="stringliteral">&quot; from thread &quot;</span> &lt;&lt; id; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addTask(task, <span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output: Hello from thread &lt;0-3&gt;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa58e31026627818ba5695b979c9340aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58e31026627818ba5695b979c9340aa">&#9670;&nbsp;</a></span>addTask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ecs::ThreadPool::addTask </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::future&lt; decltype(func(arguments...))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new task to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function which will be executed by one of the threads. </td></tr>
    <tr><td class="paramname">arguments</td><td>The extra arguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>Signature of the mentioned function. User doesn't need to explicitly specify it. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the extra erguments passed to the function func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::future of the passed task, which after execution will hold the returned result (if any).</dd></dl>
<p>This method is and overload of the previous <a class="el" href="classecs_1_1_thread_pool.html#ab328a842f3862c0a27db52c4dcc10747" title="Adds a new task to the queue.">addTask()</a> and it does not require to add a const int argument to the function parameters.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> task(std::string additional_parameter) { std::cout &lt;&lt; additional_parameter; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){  <span class="comment">// main as an example, the caller function/method can be whatever</span></div>
<div class="line">    <a class="code" href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a> TP(4);  <span class="comment">// setting thread count to 4</span></div>
<div class="line">    TP.addTask(task, <span class="stringliteral">&quot;Hello world!&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Output: Hello world!</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2e476ddc2bd3dd92b4ff1c065fd63065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e476ddc2bd3dd92b4ff1c065fd63065">&#9670;&nbsp;</a></span>clearQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::clearQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue of tasks. </p>
<dl class="section warning"><dt>Warning</dt><dd>For internal use only. </dd></dl>

</div>
</div>
<a id="adb38043cd68a08f182039fb6d193a961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb38043cd68a08f182039fb6d193a961">&#9670;&nbsp;</a></span>getThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::thread&amp; ecs::ThreadPool::getThread </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread instance from the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The index of the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread instance. </dd></dl>

</div>
</div>
<a id="a208e35ab2af5bd86553f617ea41b8ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208e35ab2af5bd86553f617ea41b8ac3">&#9670;&nbsp;</a></span>halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::halt </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>finish_tasks</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finish_tasks</td><td>If true, all threads clear the queue before stopping, else they finish immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This member function also stops all infinite tasks. </p>

</div>
</div>
<a id="acd9ec690f14c0cc15d06b8a9bbb59d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9ec690f14c0cc15d06b8a9bbb59d50">&#9670;&nbsp;</a></span>haltInfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::haltInfinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all threads with infinite tasks. </p>
<p>The behaviour is not the same as in <a class="el" href="classecs_1_1_thread_pool.html#a208e35ab2af5bd86553f617ea41b8ac3" title="Stops all threads.">halt()</a> member function, because this one only halts currently running infinite tasks. Status of queued tasks availability is not changed (besides that all threads which were computing infinite tasks are now free to empty the queue). This method DOES NOT halt any threads for good, it only breaks the while(true) loops in infinite tasks. It is also called by the <a class="el" href="classecs_1_1_thread_pool.html" title="The class representing dynamic pool of computing threads.">ThreadPool</a> destructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>In order to add a new infinite task to the queue, <a class="el" href="classecs_1_1_thread_pool.html" title="The class representing dynamic pool of computing threads.">ThreadPool</a> has to be restarted with <a class="el" href="classecs_1_1_thread_pool.html#a1283598be193563a0f7485871bf4357c" title="Restarts the thread pool.">restart()</a> member function. </dd></dl>

</div>
</div>
<a id="a2a54ec2564e97518c1ac812cd92049dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a54ec2564e97518c1ac812cd92049dd">&#9670;&nbsp;</a></span>idleThreadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned ecs::ThreadPool::idleThreadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of idle threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The idle thread count. </dd></dl>

</div>
</div>
<a id="a1cd68ebf11e8d9214153e44eb34ceeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd68ebf11e8d9214153e44eb34ceeae">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a>&amp; ecs::ThreadPool::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted copy assignment. </p>

</div>
</div>
<a id="abb84aa429291bd997bb7aab0c824f758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb84aa429291bd997bb7aab0c824f758">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a>&amp; ecs::ThreadPool::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecs_1_1_thread_pool.html">ThreadPool</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted move assignment. </p>

</div>
</div>
<a id="ae884b4c11e1067fc7b2adbf737dd3819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae884b4c11e1067fc7b2adbf737dd3819">&#9670;&nbsp;</a></span>pendingTasksCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned ecs::ThreadPool::pendingTasksCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of pending tasks in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The pending tasks count. </dd></dl>

</div>
</div>
<a id="abe165e19b30390f76a9ef9326a230de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe165e19b30390f76a9ef9326a230de4">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::resize </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>thread_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the thread pool (changes the number of working threads). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>The new thread count.</td></tr>
  </table>
  </dd>
</dl>
<p>If the new thread count is lower than the previous one, all extra threads will finish their tasks and only then will be deleted. If the new thread count is greater, the existing threads are left uninterrupted. </p>

</div>
</div>
<a id="a1283598be193563a0f7485871bf4357c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1283598be193563a0f7485871bf4357c">&#9670;&nbsp;</a></span>restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::restart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts the thread pool. </p>
<p>Calls halt(true) and sets all flags to their initial values. </p>

</div>
</div>
<a id="aa2f782b1361dddb46f53c61c39b377fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f782b1361dddb46f53c61c39b377fc">&#9670;&nbsp;</a></span>setupThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ecs::ThreadPool::setupThread </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes a thread for computing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the thread in the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For internal use only. </dd></dl>

</div>
</div>
<a id="a0a4ecc48197127c0c4ef0a6235760597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4ecc48197127c0c4ef0a6235760597">&#9670;&nbsp;</a></span>totalThreadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_thread_pool_8h.html#aa1b14b61c2957e80963c8ae1148bcc0b">NDMESSAGE</a> const unsigned ecs::ThreadPool::totalThreadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The thread count. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4e568cb7d681a0ce9c60ed754e67b273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e568cb7d681a0ce9c60ed754e67b273">&#9670;&nbsp;</a></span>m_abortFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;std::atomic&lt;bool&gt; &gt; &gt; ecs::ThreadPool::m_abortFlags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abort flags for threads. </p>

</div>
</div>
<a id="a3eb8a7cc00049e7999b5e2bcaad2da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb8a7cc00049e7999b5e2bcaad2da21">&#9670;&nbsp;</a></span>m_cond</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable ecs::ThreadPool::m_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The global condition variable used for notifying and syncing all threads. </p>

</div>
</div>
<a id="aad5be0fb027093062de23e0b006de4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5be0fb027093062de23e0b006de4bc">&#9670;&nbsp;</a></span>m_finishedFlag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; ecs::ThreadPool::m_finishedFlag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The flag describing if all tasks have benn completed. </p>

</div>
</div>
<a id="ad3c071ae20800eeeeab50feac14ffc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c071ae20800eeeeab50feac14ffc33">&#9670;&nbsp;</a></span>m_haltFlag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; ecs::ThreadPool::m_haltFlag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The global flag used for hard halting computation of all threads. </p>

</div>
</div>
<a id="a218f45a02bde7e9978f078bf6c7d53a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f45a02bde7e9978f078bf6c7d53a1">&#9670;&nbsp;</a></span>m_infHaltFlag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; ecs::ThreadPool::m_infHaltFlag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The global flag used for breaking infinite tasks. </p>

</div>
</div>
<a id="a37ac8412f189847a24b3df04efac75fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ac8412f189847a24b3df04efac75fc">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex ecs::ThreadPool::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The global mutex of the <a class="el" href="classecs_1_1_thread_pool.html" title="The class representing dynamic pool of computing threads.">ThreadPool</a> class. </p>

</div>
</div>
<a id="a9e624de9d93cd6182f5a8b6bd7eeffdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e624de9d93cd6182f5a8b6bd7eeffdb">&#9670;&nbsp;</a></span>m_pendingTasksCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;unsigned&gt; ecs::ThreadPool::m_pendingTasksCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of pending tasks in the queue. </p>

</div>
</div>
<a id="a0472a17346187879cf61165de548f4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0472a17346187879cf61165de548f4b1">&#9670;&nbsp;</a></span>m_queue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classecs_1_1impl_1_1_safe_queue.html">impl::SafeQueue</a>&lt;std::function&lt;void(const int)&gt; *&gt; ecs::ThreadPool::m_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The queue of tasks assigned by the user. </p>

</div>
</div>
<a id="ac735d2da7345482bc841608c0b06a6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac735d2da7345482bc841608c0b06a6fe">&#9670;&nbsp;</a></span>m_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;std::thread&gt; &gt; ecs::ThreadPool::m_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The container for threads. </p>

</div>
</div>
<a id="a5c683b6f2a282ac8caa8fc524a04f30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c683b6f2a282ac8caa8fc524a04f30c">&#9670;&nbsp;</a></span>m_waitingThreadsCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;unsigned&gt; ecs::ThreadPool::m_waitingThreadsCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of idle threads. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>S:/PROGRAMMING/CPP/ecs/include/<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassecs_1_1_thread_pool_html"><div class="ttname"><a href="classecs_1_1_thread_pool.html">ecs::ThreadPool</a></div><div class="ttdoc">The class representing dynamic pool of computing threads.</div><div class="ttdef"><b>Definition:</b> ThreadPool.h:97</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 28 2021 18:44:27 for Entity Component System by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
