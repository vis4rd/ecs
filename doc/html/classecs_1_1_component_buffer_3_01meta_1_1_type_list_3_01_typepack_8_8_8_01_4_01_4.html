<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Entity Component System: ecs::ComponentBuffer&lt; meta::TypeList&lt; Typepack... &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Entity Component System
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Entity Component System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecs.html">ecs</a></li><li class="navelem"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html">ComponentBuffer&lt; meta::TypeList&lt; Typepack... &gt; &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecs::ComponentBuffer&lt; meta::TypeList&lt; Typepack... &gt; &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classecs_1_1_component_buffer.html" title="Class predeclaration.">ComponentBuffer</a> handling entities' conmponents.  
 <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_component_buffer_8h_source.html">ComponentBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bc07ea6388d4054dec7e70f36f9f619"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a6bc07ea6388d4054dec7e70f36f9f619">ComponentBuffer</a> (const uint64 max_entity_count=uint64{1000})</td></tr>
<tr class="separator:a6bc07ea6388d4054dec7e70f36f9f619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b71c6e30a4df31577de01cafcb97be"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:aa6b71c6e30a4df31577de01cafcb97be"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classecs_1_1_component_wrapper.html">ComponentWrapper</a>&lt; ComponentT &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa6b71c6e30a4df31577de01cafcb97be">getComponentBucket</a> ()</td></tr>
<tr class="memdesc:aa6b71c6e30a4df31577de01cafcb97be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of components of given type.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa6b71c6e30a4df31577de01cafcb97be">More...</a><br /></td></tr>
<tr class="separator:aa6b71c6e30a4df31577de01cafcb97be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a6fdc9e3afcd02cf1953ab5fffd284"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:aa1a6fdc9e3afcd02cf1953ab5fffd284"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; ComponentT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284">tryGetComponent</a> (const uint64 entity_id) noexcept</td></tr>
<tr class="memdesc:aa1a6fdc9e3afcd02cf1953ab5fffd284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to get the specific component from the buffer.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284">More...</a><br /></td></tr>
<tr class="separator:aa1a6fdc9e3afcd02cf1953ab5fffd284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0340757a145e29a5179194eacfb16c"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:acd0340757a145e29a5179194eacfb16c"><td class="memTemplItemLeft" align="right" valign="top">ComponentT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#acd0340757a145e29a5179194eacfb16c">getComponent</a> (const uint64 entity_id)</td></tr>
<tr class="memdesc:acd0340757a145e29a5179194eacfb16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested component of given type and entity id.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#acd0340757a145e29a5179194eacfb16c">More...</a><br /></td></tr>
<tr class="separator:acd0340757a145e29a5179194eacfb16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536361f822e2f168a9d6d5ba8bafc34"><td class="memTemplParams" colspan="2">template&lt;typename... ComponentListT&gt; </td></tr>
<tr class="memitem:a2536361f822e2f168a9d6d5ba8bafc34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a2536361f822e2f168a9d6d5ba8bafc34">getComponentsMatching</a> (const uint64 entity_id)</td></tr>
<tr class="memdesc:a2536361f822e2f168a9d6d5ba8bafc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::tuple with objects of component types matching given entity_id.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a2536361f822e2f168a9d6d5ba8bafc34">More...</a><br /></td></tr>
<tr class="separator:a2536361f822e2f168a9d6d5ba8bafc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb96a24657b9993061f6f78fb1c79e7"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:affb96a24657b9993061f6f78fb1c79e7"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#affb96a24657b9993061f6f78fb1c79e7">addComponent</a> (const uint64 entity_id)</td></tr>
<tr class="memdesc:affb96a24657b9993061f6f78fb1c79e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new component of given type and entity id to the buffer.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#affb96a24657b9993061f6f78fb1c79e7">More...</a><br /></td></tr>
<tr class="separator:affb96a24657b9993061f6f78fb1c79e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab071000c6665ff040527a286fe0a4628"><td class="memTemplParams" colspan="2">template&lt;uint16 decimalIndex&gt; </td></tr>
<tr class="memitem:ab071000c6665ff040527a286fe0a4628"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ab071000c6665ff040527a286fe0a4628">addComponentByIndex</a> (const uint64 entity_id)</td></tr>
<tr class="memdesc:ab071000c6665ff040527a286fe0a4628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new component using decimal index of its type in the pool.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ab071000c6665ff040527a286fe0a4628">More...</a><br /></td></tr>
<tr class="separator:ab071000c6665ff040527a286fe0a4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d7b3bb40645a97c004be73d360719"><td class="memTemplParams" colspan="2">template&lt;uint16 decimalIndex&gt; </td></tr>
<tr class="memitem:a7d0d7b3bb40645a97c004be73d360719"><td class="memTemplItemLeft" align="right" valign="top">const std::optional&lt; meta::TypeAt&lt; decimalIndex, <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a7d0d7b3bb40645a97c004be73d360719">getComponentByIndex</a> (const uint64 entity_id) const noexcept</td></tr>
<tr class="memdesc:a7d0d7b3bb40645a97c004be73d360719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the existing component using decimal index of its type in the pool.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a7d0d7b3bb40645a97c004be73d360719">More...</a><br /></td></tr>
<tr class="separator:a7d0d7b3bb40645a97c004be73d360719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e96f6c2f04fc52ada8af1fc539a67d"><td class="memTemplParams" colspan="2">template&lt;uint16 decimalIndex&gt; </td></tr>
<tr class="memitem:ab3e96f6c2f04fc52ada8af1fc539a67d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; meta::TypeAt&lt; decimalIndex, <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ab3e96f6c2f04fc52ada8af1fc539a67d">getComponentByIndex</a> (const uint64 entity_id) noexcept</td></tr>
<tr class="memdesc:ab3e96f6c2f04fc52ada8af1fc539a67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the existing component using decimal index of its type in the pool.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ab3e96f6c2f04fc52ada8af1fc539a67d">More...</a><br /></td></tr>
<tr class="separator:ab3e96f6c2f04fc52ada8af1fc539a67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9243e8f8be60471d6e1239666298a97e"><td class="memTemplParams" colspan="2">template&lt;uint16 Index = (sizeof... (Typepack) - 1)&gt; </td></tr>
<tr class="memitem:a9243e8f8be60471d6e1239666298a97e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a9243e8f8be60471d6e1239666298a97e">clear</a> () noexcept</td></tr>
<tr class="memdesc:a9243e8f8be60471d6e1239666298a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all existing components in the buffer.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a9243e8f8be60471d6e1239666298a97e">More...</a><br /></td></tr>
<tr class="separator:a9243e8f8be60471d6e1239666298a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade57bb601968c4ded9cdf5c7d151d3ef"><td class="memTemplParams" colspan="2">template&lt;uint16 decimalIndex&gt; </td></tr>
<tr class="memitem:ade57bb601968c4ded9cdf5c7d151d3ef"><td class="memTemplItemLeft" align="right" valign="top">const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ade57bb601968c4ded9cdf5c7d151d3ef">checkComponent</a> (const uint64 entity_id) const noexcept</td></tr>
<tr class="memdesc:ade57bb601968c4ded9cdf5c7d151d3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether component of given index of type in the pool and entity id exists.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ade57bb601968c4ded9cdf5c7d151d3ef">More...</a><br /></td></tr>
<tr class="separator:ade57bb601968c4ded9cdf5c7d151d3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09929802b05271157b6beb40400120ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a09929802b05271157b6beb40400120ae">removeComponents</a> (const uint64 entity_id) noexcept</td></tr>
<tr class="memdesc:a09929802b05271157b6beb40400120ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all components from the buffer belonging to the given entity id.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a09929802b05271157b6beb40400120ae">More...</a><br /></td></tr>
<tr class="separator:a09929802b05271157b6beb40400120ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc2e1fd6ce1716cbafbaf02638c512e"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:a2dc2e1fd6ce1716cbafbaf02638c512e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a2dc2e1fd6ce1716cbafbaf02638c512e">removeComponent</a> (const uint64 entity_id)</td></tr>
<tr class="memdesc:a2dc2e1fd6ce1716cbafbaf02638c512e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a component of given type and entity id from the buffer.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a2dc2e1fd6ce1716cbafbaf02638c512e">More...</a><br /></td></tr>
<tr class="separator:a2dc2e1fd6ce1716cbafbaf02638c512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a803abcf60aabedfe73493ed3c3a36"><td class="memItemLeft" align="right" valign="top">const uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a87a803abcf60aabedfe73493ed3c3a36">size</a> () const</td></tr>
<tr class="memdesc:a87a803abcf60aabedfe73493ed3c3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of components in the buffer.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a87a803abcf60aabedfe73493ed3c3a36">More...</a><br /></td></tr>
<tr class="separator:a87a803abcf60aabedfe73493ed3c3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8deb9aea5729077c29e4a9ce057d5ab"><td class="memTemplParams" colspan="2">template&lt;typename ComponentT &gt; </td></tr>
<tr class="memitem:ac8deb9aea5729077c29e4a9ce057d5ab"><td class="memTemplItemLeft" align="right" valign="top">const uint64&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ac8deb9aea5729077c29e4a9ce057d5ab">bucketSize</a> () const</td></tr>
<tr class="memdesc:ac8deb9aea5729077c29e4a9ce057d5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the specific bucket containing components of given type.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ac8deb9aea5729077c29e4a9ce057d5ab">More...</a><br /></td></tr>
<tr class="separator:ac8deb9aea5729077c29e4a9ce057d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7b1f9f9b2defb22639579ce8eee32d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aea7b1f9f9b2defb22639579ce8eee32d">printAll</a> () const</td></tr>
<tr class="memdesc:aea7b1f9f9b2defb22639579ce8eee32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method used for debugging.  <a href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aea7b1f9f9b2defb22639579ce8eee32d">More...</a><br /></td></tr>
<tr class="separator:aea7b1f9f9b2defb22639579ce8eee32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ae0d017f2ecacd970cbb7ed01861d82ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ae0d017f2ecacd970cbb7ed01861d82ff">m_cPool</a> = <a class="el" href="namespaceecs_1_1meta.html#a3466b48297bec90d06a6e770a90813b7">meta::ComponentPool</a>&lt; <a class="el" href="classecs_1_1_component_wrapper.html">ComponentWrapper</a>&lt; Typepack &gt; ... &gt;</td></tr>
<tr class="separator:ae0d017f2ecacd970cbb7ed01861d82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a093ff854de0030cbc2c58406ff0b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a> = meta::TypeList&lt; Typepack... &gt;</td></tr>
<tr class="separator:a05a093ff854de0030cbc2c58406ff0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a663b628c007753f521a798b697d0537a"><td class="memItemLeft" align="right" valign="top">meta::metautil::TupleOfVectorsOfTypes&lt; <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ae0d017f2ecacd970cbb7ed01861d82ff">m_cPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a663b628c007753f521a798b697d0537a">m_cBuffer</a></td></tr>
<tr class="separator:a663b628c007753f521a798b697d0537a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1591b2319683d47db1d1f514a236865"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1591b2319683d47db1d1f514a236865">m_maxEntityCount</a></td></tr>
<tr class="separator:aa1591b2319683d47db1d1f514a236865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... Typepack&gt;<br />
class ecs::ComponentBuffer&lt; meta::TypeList&lt; Typepack... &gt; &gt;</h3>

<p>The <a class="el" href="classecs_1_1_component_buffer.html" title="Class predeclaration.">ComponentBuffer</a> handling entities' conmponents. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Typepack</td><td>Pack of component types used in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Every component is wrapped in the buffer so that in some places interface is unified. <a class="el" href="classecs_1_1_component_wrapper.html" title="Class wrapping components for ComponentBuffer.">ComponentWrapper</a> also helps in recognizing which components belong to which entities. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae0d017f2ecacd970cbb7ed01861d82ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d017f2ecacd970cbb7ed01861d82ff">&#9670;&nbsp;</a></span>m_cPool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ae0d017f2ecacd970cbb7ed01861d82ff">m_cPool</a> =  <a class="el" href="namespaceecs_1_1meta.html#a3466b48297bec90d06a6e770a90813b7">meta::ComponentPool</a>&lt;<a class="el" href="classecs_1_1_component_wrapper.html">ComponentWrapper</a>&lt;Typepack&gt; ...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05a093ff854de0030cbc2c58406ff0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a093ff854de0030cbc2c58406ff0b8">&#9670;&nbsp;</a></span>m_tPool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a> =  meta::TypeList&lt;Typepack...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6bc07ea6388d4054dec7e70f36f9f619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc07ea6388d4054dec7e70f36f9f619">&#9670;&nbsp;</a></span>ComponentBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::<a class="el" href="classecs_1_1_component_buffer.html">ComponentBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>max_entity_count</em> = <code>uint64{1000}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="affb96a24657b9993061f6f78fb1c79e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb96a24657b9993061f6f78fb1c79e7">&#9670;&nbsp;</a></span>addComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::addComponent </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new component of given type and entity id to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>The type of the added component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If both component type and entity id are valid, the created instance of component is returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method does not check whether such component already exists. If there are two instances of the same component with equal entity id, the behaviour of whole buffer is undefined. For additional safety in this matter, see <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284" title="Tries to get the specific component from the buffer.">tryGetComponent()</a> method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::optional&lt;ComponentT&gt; &amp;<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284" title="Tries to get the specific component from the buffer.">tryGetComponent(const uint64 entity_id)</a> noexcept</dd></dl>
<p>The returned component reference is unwrapped from <a class="el" href="classecs_1_1_component_wrapper.html" title="Class wrapping components for ComponentBuffer.">ComponentWrapper</a>. </p>

</div>
</div>
<a id="ab071000c6665ff040527a286fe0a4628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab071000c6665ff040527a286fe0a4628">&#9670;&nbsp;</a></span>addComponentByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;uint16 decimalIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::addComponentByIndex </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new component using decimal index of its type in the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decimalIndex</td><td>Index of the component type in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If both component index and entity id are valid, the created instance of component is returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method does not check whether such component already exists. If there are two instances of the same component with equal entity id, the behaviour of whole buffer is undefined. For additional safety in this matter, see <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284" title="Tries to get the specific component from the buffer.">tryGetComponent()</a> method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::optional&lt;ComponentT&gt; &amp;<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa1a6fdc9e3afcd02cf1953ab5fffd284" title="Tries to get the specific component from the buffer.">tryGetComponent(const uint64 entity_id)</a> noexcept</dd></dl>
<p>The returned component reference is unwrapped from <a class="el" href="classecs_1_1_component_wrapper.html" title="Class wrapping components for ComponentBuffer.">ComponentWrapper</a>. </p>

</div>
</div>
<a id="ac8deb9aea5729077c29e4a9ce057d5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8deb9aea5729077c29e4a9ce057d5ab">&#9670;&nbsp;</a></span>bucketSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint64 <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::bucketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size of the specific bucket containing components of given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>Type of the component, which container's size is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decimal number of components in the bucket of passed type.</dd></dl>
<p>The size value is acquired by calling <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa6b71c6e30a4df31577de01cafcb97be" title="Gets the vector of components of given type.">getComponentBucket()</a> method, so all safety/exception rules apply from it.</p>
<dl class="section see"><dt>See also</dt><dd>std::vector&lt;ComponentWrapper&lt;ComponentT&gt;&gt; &amp;<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#aa6b71c6e30a4df31577de01cafcb97be" title="Gets the vector of components of given type.">getComponentBucket()</a> </dd></dl>

</div>
</div>
<a id="ade57bb601968c4ded9cdf5c7d151d3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade57bb601968c4ded9cdf5c7d151d3ef">&#9670;&nbsp;</a></span>checkComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;uint16 decimalIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::checkComponent </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether component of given index of type in the pool and entity id exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decimalIndex</td><td>Index of the component type in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean value specifying whether such component exists or not.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Although this method is marked noexcept, it still can terminate the program when given decimalIndex is invalid (out of range). </dd></dl>

</div>
</div>
<a id="a9243e8f8be60471d6e1239666298a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9243e8f8be60471d6e1239666298a97e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;uint16 Index = (sizeof... (Typepack) - 1)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all existing components in the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>This parameter should not be explicitly passed by the user, as it is used only as a help for template recursion.</td></tr>
  </table>
  </dd>
</dl>
<p>Explicitly passing a value to the Index will cause program termination or incorrect clear of the buffer. </p>

</div>
</div>
<a id="acd0340757a145e29a5179194eacfb16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0340757a145e29a5179194eacfb16c">&#9670;&nbsp;</a></span>getComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ComponentT&amp; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::getComponent </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested component of given type and entity id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>The type of the requested component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the type and entity id exists, the requested component is returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is unsafe, beacuse if any of the passed arguments/params are invalid, it throws an exception. </dd></dl>

</div>
</div>
<a id="aa6b71c6e30a4df31577de01cafcb97be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b71c6e30a4df31577de01cafcb97be">&#9670;&nbsp;</a></span>getComponentBucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classecs_1_1_component_wrapper.html">ComponentWrapper</a>&lt;ComponentT&gt; &gt;&amp; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::getComponentBucket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vector of components of given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>The type of the requested component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component bucket if the given type exists, otherwise an exception is thrown.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method returns vector of wrapped components. </dd></dl>

</div>
</div>
<a id="a7d0d7b3bb40645a97c004be73d360719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0d7b3bb40645a97c004be73d360719">&#9670;&nbsp;</a></span>getComponentByIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;uint16 decimalIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt;meta::TypeAt&lt;decimalIndex, <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a>&gt; &gt; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::getComponentByIndex </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the existing component using decimal index of its type in the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decimalIndex</td><td>Index of the component type in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If both component index and entity id are valid, the requested instance of component is returned wrapped in std::optional object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there's no component with given entity id or type index is invalid, the returned value is std::nullopt instead. </dd></dl>

</div>
</div>
<a id="ab3e96f6c2f04fc52ada8af1fc539a67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e96f6c2f04fc52ada8af1fc539a67d">&#9670;&nbsp;</a></span>getComponentByIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;uint16 decimalIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;meta::TypeAt&lt;decimalIndex, <a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#a05a093ff854de0030cbc2c58406ff0b8">m_tPool</a>&gt; &gt; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::getComponentByIndex </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the existing component using decimal index of its type in the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decimalIndex</td><td>Index of the component type in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If both component index and entity id are valid, the requested instance of component is returned wrapped in std::optional object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there's no component with given entity id or type index is invalid, the returned value is std::nullopt instead.</dd></dl>
<p>This is a non-const version of this method provided for convenience. </p>

</div>
</div>
<a id="a2536361f822e2f168a9d6d5ba8bafc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2536361f822e2f168a9d6d5ba8bafc34">&#9670;&nbsp;</a></span>getComponentsMatching()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename... ComponentListT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::getComponentsMatching </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns std::tuple with objects of component types matching given entity_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentListT</td><td>The list of types of requested components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of components matching passed ComponentListT.</dd></dl>
<p>This method neither does check whether user passed any component types as template parameters nor checks if given component types exist in the pool.</p>
<dl class="section warning"><dt>Warning</dt><dd>This metod is unsafe, because if any of the passed arguments/params are invalid, it throws an exception. </dd></dl>

</div>
</div>
<a id="aea7b1f9f9b2defb22639579ce8eee32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7b1f9f9b2defb22639579ce8eee32d">&#9670;&nbsp;</a></span>printAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::printAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method used for debugging. </p>
<p>It prints all types and component values currently existing in the buffer. </p>

</div>
</div>
<a id="a2dc2e1fd6ce1716cbafbaf02638c512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc2e1fd6ce1716cbafbaf02638c512e">&#9670;&nbsp;</a></span>removeComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::removeComponent </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a component of given type and entity id from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>Type of the component which is supposed to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method will throw an exception if given component type or entity id are invalid. </dd></dl>

</div>
</div>
<a id="a09929802b05271157b6beb40400120ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09929802b05271157b6beb40400120ae">&#9670;&nbsp;</a></span>removeComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::removeComponents </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all components from the buffer belonging to the given entity id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is safe to use as it will not throw any exception and given arguments can be invalid. </dd></dl>

</div>
</div>
<a id="a87a803abcf60aabedfe73493ed3c3a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a803abcf60aabedfe73493ed3c3a36">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint64 <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of components in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Decimal number of components in the buffer. </dd></dl>

</div>
</div>
<a id="aa1a6fdc9e3afcd02cf1953ab5fffd284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a6fdc9e3afcd02cf1953ab5fffd284">&#9670;&nbsp;</a></span>tryGetComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<div class="memtemplate">
template&lt;typename ComponentT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;ComponentT&gt;&amp; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::tryGetComponent </td>
          <td>(</td>
          <td class="paramtype">const uint64&#160;</td>
          <td class="paramname"><em>entity_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to get the specific component from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_id</td><td>The entity identifier (automatically attached to every created entity). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentT</td><td>The type of the requested component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional object. If given componentn type does not exist, this method returns std::nullopt. Otherwise gets an existing component or creates and returns a new one. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a663b628c007753f521a798b697d0537a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663b628c007753f521a798b697d0537a">&#9670;&nbsp;</a></span>m_cBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">meta::metautil::TupleOfVectorsOfTypes&lt;<a class="el" href="classecs_1_1_component_buffer_3_01meta_1_1_type_list_3_01_typepack_8_8_8_01_4_01_4.html#ae0d017f2ecacd970cbb7ed01861d82ff">m_cPool</a>&gt; <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::m_cBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Container holding all components in the buffer. </p>

</div>
</div>
<a id="aa1591b2319683d47db1d1f514a236865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1591b2319683d47db1d1f514a236865">&#9670;&nbsp;</a></span>m_maxEntityCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Typepack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 <a class="el" href="classecs_1_1_component_buffer.html">ecs::ComponentBuffer</a>&lt; meta::TypeList&lt; Typepack... &gt; &gt;::m_maxEntityCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximal possible number of entities which can fit into the buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>S:/PROGRAMMING/CPP/ecs/include/<a class="el" href="_component_buffer_8h_source.html">ComponentBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 28 2021 18:44:26 for Entity Component System by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
